<!-- HEADER -->
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

  <title>Learn Prolog Now!</title>

  <link href="Learn%20Prolog%20Now!5.2_files/lpn_reds2.css" rel="stylesheet" type="text/css">

  </head>

  <body>

  <!-- table is needed because IE doesn't recognize min-width. -->
  <table width="100%">
  <tbody><tr><td><div style="width:500pt;"></div></td></tr>
  <tr><td>

  <div class="coloredbar"></div>
  <div class="lpnheader">
  <a href="http://www.learnprolognow.org/index.php">Learn Prolog Now!</a>
  </div>

  
  <div class="authorbar">
  by <a href="http://www.loria.fr/~blackbur/">Patrick Blackburn</a>, 
     <a href="http://www.let.rug.nl/bos/">Johan Bos</a>, and 
     <a href="http://cs.union.edu/~striegnk/">Kristina Striegnitz</a>
  </div>

<!-- NAVIGATION BAR -->
  <div class="navbar">
  <ul><li><a href="http://www.learnprolognow.org/lpnpage.php?pageid=top">LPN! Home</a></li><li><a href="http://www.learnprolognow.org/lpnpage.php?pageid=online">Free Online Version</a></li><li><a href="http://www.learnprolognow.org/lpnpage.php?pageid=handheld">Paperback English</a></li><li><a href="http://www.learnprolognow.org/lpnpage.php?pageid=french">Paperback Français</a></li><li><a href="http://www.learnprolognow.org/lpnpage.php?pageid=teaching">Teaching Prolog</a></li><li><a href="http://www.learnprolognow.org/lpnpage.php?pageid=implementations">Prolog Implementations</a></li><li><a href="http://www.learnprolognow.org/lpnpage.php?pageid=manuals">Prolog Manuals</a></li><li><a href="http://www.learnprolognow.org/lpnpage.php?pageid=links">Prolog Links</a></li><li><a href="http://www.learnprolognow.org/lpnpage.php?pageid=thanks">Thanks!</a></li><li><a href="http://www.learnprolognow.org/lpnpage.php?pageid=contact">Contact us</a></li></ul>  </div>


<!-- MAIN CONTENT -->
  <div class="content">

  
<!--l. 120--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse20"> next 
</a> ] [ 
<a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse18"> prev 
</a> ] [ 
<a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse18"> prev-tail 
</a> ] [ 
<a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=#taillpn-htmlse19"> tail 
</a> ] [ 
<a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p> 
</div> 
<h3 class="sectionHead"> 
<span class="titlemark"> 5.2 
</span> 
<a id="x34-470005.2"> 
</a> A Closer Look 
</h3> 
<!--l. 122--> 
<p class="noindent"> That’s the basics, but we need to know more. The most important to grasp is this: +, *, -, 
<span class="cmsy-10"> ÷ 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> mod 
</span> 
</span> do 
<span class="cmti-10"> not 
</span> carry out any arithmetic. In fact, expressions such as 
<span class="verb"> 
<span class="cmtt-10"> 3+2 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> 3-2 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> 3*2 
</span> 
</span> are simply terms. The functors of these terms are 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> - 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> * 
</span> 
</span> respectively, and the arguments are 
<span class="verb"> 
<span class="cmtt-10"> 3 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> 2 
</span> 
</span> . Apart from the fact that the functors go between their 
arguments (instead of in front of them) these are ordinary Prolog terms,
 and unless we do something special, Prolog will not actually do any 
arithmetic. In particular, if we pose the query 
</p> 
<div class="fancyvrb" id="fancyvrb235"> 
<a id="x34-47002r1"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;?- 
</span> 
<span class="cmtt-10"> &nbsp;X 
</span> 
<span class="cmtt-10"> &nbsp;= 
</span> 
<span class="cmtt-10"> &nbsp;3+2 
</span> 
</div> 
<!--l. 134--> 
<p class="noindent"> we don’t get back the answer 
<span class="verb"> 
<span class="cmtt-10"> X=5 
</span> 
</span> . Instead we get back 
</p> 
<div class="fancyvrb" id="fancyvrb236"> 
<a id="x34-47004r1"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;X 
</span> 
<span class="cmtt-10"> &nbsp;= 
</span> 
<span class="cmtt-10"> &nbsp;3+2 
</span> 
<br class="fancyvrb"> 
<a id="x34-47006r2"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;yes 
</span> 
</div> 
<!--l. 140--> 
<p class="noindent"> That is, Prolog has simply unified the variable 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> to the complex term 
<span class="verb"> 
<span class="cmtt-10"> 3+2 
</span> 
</span> . It has 
<span class="cmti-10"> not 
</span> carried out any arithmetic. It has simply done what it usually does when 
<span class="cmtt-10"> =/2 
</span> is used: performed unification. 
</p> 
<!--l. 145--> 
<p class="indent"> Similarly, if we pose the query 
</p> 
<div class="fancyvrb" id="fancyvrb237"> 
<a id="x34-47008r1"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;?- 
</span> 
<span class="cmtt-10"> &nbsp;3+2*5 
</span> 
<span class="cmtt-10"> &nbsp;= 
</span> 
<span class="cmtt-10"> &nbsp;X 
</span> 
</div> 
<!--l. 150--> 
<p class="noindent"> we get the response 
</p> 
<div class="fancyvrb" id="fancyvrb238"> 
<a id="x34-47010r1"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;X 
</span> 
<span class="cmtt-10"> &nbsp;= 
</span> 
<span class="cmtt-10"> &nbsp;3+2*5 
</span> 
<br class="fancyvrb"> 
<a id="x34-47012r2"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;yes 
</span> 
</div> 
<!--l. 155--> 
<p class="noindent"> Again, Prolog has simply bound the variable 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> to the complex term 
<span class="verb"> 
<span class="cmtt-10"> 3+2*5 
</span> 
</span> . It did not evaluate this expression to 13. 
</p> 
<!--l. 158--> 
<p class="indent"> To force Prolog to actually evaluate arithmetic expressions we have to use 
</p> 
<div class="fancyvrb" id="fancyvrb239"> 
<a id="x34-47014r1"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;is 
</span> 
</div> 
<!--l. 163--> 
<p class="noindent"> just as we did in our earlier examples. In fact, 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> does something very special: it sends a signal to Prolog that 
says “Hey! Don’t treat this expression as an ordinary complex term! Call
 up your built-in arithmetic capabilities and carry out the 
calculations!” 
</p> 
<!--l. 168--> 
<p class="indent"> In short, 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> forces Prolog to act in an unusual way. Normally Prolog is quite
 happy just unifying variables to structures: that’s its job, after all.
 Arithmetic is something extra that has been bolted on to the basic 
Prolog engine because it is useful. Unsurprisingly, there are some 
restrictions on this extra ability, and we need to know what they are. 
</p> 
<!--l. 175--> 
<p class="indent"> For a start, the arithmetic expressions to be evaluated must be on the right hand side of 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> . In our earlier examples we carefully posed the query 
</p> 
<div class="fancyvrb" id="fancyvrb240"> 
<a id="x34-47016r1"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;?- 
</span> 
<span class="cmtt-10"> &nbsp;X 
</span> 
<span class="cmtt-10"> &nbsp;is 
</span> 
<span class="cmtt-10"> &nbsp;6+2. 
</span> 
<br class="fancyvrb"> 
<a id="x34-47018r2"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp; 
</span> 
<br class="fancyvrb"> 
<a id="x34-47020r3"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;X 
</span> 
<span class="cmtt-10"> &nbsp;= 
</span> 
<span class="cmtt-10"> &nbsp;8 
</span> 
</div> 
<!--l. 183--> 
<p class="noindent"> which is the right way to do it. If instead we had asked 
</p> 
<div class="fancyvrb" id="fancyvrb241"> 
<a id="x34-47022r1"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;6+2 
</span> 
<span class="cmtt-10"> &nbsp;is 
</span> 
<span class="cmtt-10"> &nbsp;X. 
</span> 
</div> 
<!--l. 188--> 
<p class="noindent"> we would have got a message saying 
<span class="verb"> 
<span class="cmtt-10"> instantiation_error 
</span> 
</span> , or something similar. 
</p> 
<!--l. 191--> 
<p class="indent"> Moreover, although we are free to use variables on the right hand side of 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> , when we actually carry out evaluation, the variable must 
already have been instantiated to a variable-free arithmetic expression.
 If the variable is uninstantiated, or if it is instantiated to 
something other than an integer, we will get some sort of 
<span class="verb"> 
<span class="cmtt-10"> instantiation_error 
</span> 
</span> message. This is because arithmetic isn’t performed using 
Prolog’s usual unification and knowledge base search mechanisms: it’s 
done by calling up a special black box which knows about integer 
arithmetic. If we hand the black box the wrong kind of data, it’s going 
to complain. 
</p> 
<!--l. 202--> 
<p class="indent"> Here’s an example. Recall our “add 3 and double it” predicate. 
</p> 
<div class="fancyvrb" id="fancyvrb242"> 
<a id="x34-47024r1"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;add_3_and_double(X,Y) 
</span> 
<span class="cmtt-10"> &nbsp;:- 
</span> 
<span class="cmtt-10"> &nbsp;Y 
</span> 
<span class="cmtt-10"> &nbsp;is 
</span> 
<span class="cmtt-10"> &nbsp;(X+3)*2. 
</span> 
</div> 
<!--l. 207--> 
<p class="noindent"> When we described this predicate, we carefully said
 that it added 3 to its first argument, doubled the result, and returned
 the answer in its second argument. For example, 
<span class="verb"> 
<span class="cmtt-10"> add_3_and_double(3,X) 
</span> 
</span> returns 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &nbsp;= 
</span> 
<span class="cmtt-10"> &nbsp;12 
</span> 
</span> . We didn’t say anything about using this predicate in the reverse direction. For example, we might hope that posing the query 
</p> 
<div class="fancyvrb" id="fancyvrb243"> 
<a id="x34-47026r1"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;?- 
</span> 
<span class="cmtt-10"> &nbsp;add_3_and_double(X,12). 
</span> 
</div> 
<!--l. 216--> 
<p class="noindent"> would return the answer 
<span class="verb"> 
<span class="cmtt-10"> X=3 
</span> 
</span> . But it doesn’t. Instead we get the 
<span class="verb"> 
<span class="cmtt-10"> instantiation_error 
</span> 
</span> message. Why? Well, when we pose the query this way round, we are asking Prolog to evaluate 
<span class="verb"> 
<span class="cmtt-10"> 12 
</span> 
<span class="cmtt-10"> &nbsp;is 
</span> 
<span class="cmtt-10"> &nbsp;(X+3)*2 
</span> 
</span> , which it 
<span class="cmti-10"> can’t 
</span> do as 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> is not instantiated. 
</p> 
<!--l. 222--> 
<p class="indent"> Two final remarks. As we’ve already mentioned, for Prolog 
<span class="verb"> 
<span class="cmtt-10"> 3 
</span> 
<span class="cmtt-10"> &nbsp;+ 
</span> 
<span class="cmtt-10"> &nbsp;2 
</span> 
</span> is just a term. In fact, for Prolog, it really 
<span class="cmti-10"> is 
</span> the term 
<span class="cmti-10"> +(3,2) 
</span> . The expression 
<span class="verb"> 
<span class="cmtt-10"> 3 
</span> 
<span class="cmtt-10"> &nbsp;+ 
</span> 
<span class="cmtt-10"> &nbsp;2 
</span> 
</span> is just a user-friendly notation that’s nicer for us to use. This means that, if you want to, you can give Prolog queries like 
</p> 
<div class="fancyvrb" id="fancyvrb244"> 
<a id="x34-47028r1"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;X 
</span> 
<span class="cmtt-10"> &nbsp;is 
</span> 
<span class="cmtt-10"> &nbsp;+(3,2) 
</span> 
</div> 
<!--l. 230--> 
<p class="noindent"> and Prolog will correctly reply 
</p> 
<div class="fancyvrb" id="fancyvrb245"> 
<a id="x34-47030r1"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;X 
</span> 
<span class="cmtt-10"> &nbsp;= 
</span> 
<span class="cmtt-10"> &nbsp;5 
</span> 
</div> 
<!--l. 234--> 
<p class="noindent"> Actually, you can even given Prolog the query 
</p> 
<div class="fancyvrb" id="fancyvrb246"> 
<a id="x34-47032r1"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;?- 
</span> 
<span class="cmtt-10"> &nbsp;is(X,+(3,2)) 
</span> 
</div> 
<!--l. 238--> 
<p class="noindent"> and Prolog will respond 
</p> 
<div class="fancyvrb" id="fancyvrb247"> 
<a id="x34-47034r1"> 
</a> 
<span class="cmtt-10"> &nbsp; 
</span> 
<span class="cmtt-10"> &nbsp;X 
</span> 
<span class="cmtt-10"> &nbsp;= 
</span> 
<span class="cmtt-10"> &nbsp;5 
</span> 
</div> 
<!--l. 242--> 
<p class="noindent"> This is because, for Prolog, the expression 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &nbsp;is 
</span> 
<span class="cmtt-10"> &nbsp;+(3,2) 
</span> 
</span> really is the term 
<span class="verb"> 
<span class="cmtt-10"> is(X,+(3,2)) 
</span> 
</span> . The expression 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &nbsp;is 
</span> 
<span class="cmtt-10"> &nbsp;+(3,2) 
</span> 
</span> is just user-friendly notation. Underneath, as always, Prolog is just working away with terms. 
</p> 
<!--l. 247--> 
<p class="indent"> Summing up, arithmetic in Prolog is easy to use. Pretty much all you have to remember is to use 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> to force evaluation, that stuff to be evaluated must go to the right of 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> , and to take care that any variables are correctly 
instantiated. But there is a deeper point that is worth reflecting on: 
bolting on the extra capability to do arithmetic in this way has further
 widened the gap between the procedural and declarative meanings of 
Prolog programs. 
</p> 
<!--l. 259--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse20"> next 
</a> ] [ 
<a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse18"> prev 
</a> ] [ 
<a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse18"> prev-tail 
</a> ] [ 
<a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse19"> front 
</a> ] [ 
<a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlch5"> up 
</a> ] 
</p> 
</div> 
<!--l. 259--> 
<p class="indent"> 
<a id="taillpn-htmlse19"> 
</a> 
</p> 
  </div>


<!-- FOOTER -->
  <div class="foot">
<div class="tracker">
<div id="eXTReMe"><a href="http://extremetracking.com/open?login=lpntwo">
<img src="Learn%20Prolog%20Now!5.2_files/i.gif" style="border: 0;" id="EXim" alt="eXTReMe Tracker" width="41" height="38"></a>
<script type="text/javascript"><!--
var EXlogin='lpntwo' // Login
var EXvsrv='s11' // VServer
EXs=screen;EXw=EXs.width;navigator.appName!="Netscape"?
EXb=EXs.colorDepth:EXb=EXs.pixelDepth;
navigator.javaEnabled()==1?EXjv="y":EXjv="n";
EXd=document;EXw?"":EXw="na";EXb?"":EXb="na";
EXd.write("<img src=http://e2.extreme-dm.com",
"/"+EXvsrv+".g?login="+EXlogin+"&amp;",
"jv="+EXjv+"&amp;j=y&amp;srw="+EXw+"&amp;srb="+EXb+"&amp;",
"l="+escape(EXd.referrer)+" height=1 width=1>");//-->
</script><img src="Learn%20Prolog%20Now!5.2_files/s11.gif" width="1" height="1"><noscript><div id="neXTReMe"><img height="1" width="1" alt=""
src="http://e2.extreme-dm.com/s11.g?login=lpntwo&amp;j=n&amp;jv=n" />
</div></noscript></div>
</div>
  © 2006-2012 <a href="http://www.patrickblackburn.org/">Patrick Blackburn</a>, <a href="http://www.let.rug.nl/bos/">Johan Bos</a>, <a href="http://cs.union.edu/~striegnk/">Kristina Striegnitz</a>
  </div>

  </td></tr></tbody></table>


  


</body></html>